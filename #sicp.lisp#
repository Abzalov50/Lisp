(defun deriv (exp var)
  (cond ((and (atom exp) (not (eq exp var)))
	 0)
	((and (atom exp) (eq exp var))
	 1)
	((sum-p exp)
	 (make-sum (car exp)
		   (deriv (cadr exp) var)
		   (deriv (caddr exp) var)))
	((product-p exp)
	 (make-sum '+
		   (make-product (deriv (cadr exp) var)
				 (caddr exp))
		   (make-product (cadr exp)
				 (deriv (caddr exp) var))))
	(t (error "malformed expression"))))

(defun sum-p (exp)
  (and (consp exp) (or (eq (car exp) '+)
		       (eq (car exp) '-))))

(defun ident-sum-p (op exp)
  (and (atom exp) (numberp exp) (zerop exp) (or (eq op '+) (eq op '-))))

(defun ident-mult-p (exp)
  (and (atom exp) (numberp exp) (= exp 1)))

(defun make-sum (op e1 e2)
  (cond ((null e1) e2)
	((null e2) e1)
	((ident-sum-p op e1)
	 (if (eq op '-)
	     (list '- e2)
	     e2))
	((ident-sum-p op e2)
	 (if (eq op '-)
	     (list '- e1)
	     e1))
	(t (list op e1 e2))))

(defun product-p (exp)
  (and (consp exp) (eq (car exp) '*)))

(defun make-product (e1 e2)
  (cond ((null e1) e2)
	((null e2) e1)
	((ident-mult-p e1)
	 e2)
	((ident-mult-p e2)
	 e1)
	((and (numberp e1) (zerop e1))
	 nil)
	((and (numberp e2) (zerop e2))
	 nil)
	(t (list '* e1 e2))))
  
